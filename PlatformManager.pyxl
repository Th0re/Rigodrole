// Scripts, variables, and constants here are visible to all modes

let LEFT_SCREEN_START_X = 0
let LEFT_SCREEN_END_X = 190

let RIGHT_SCREEN_START_X = 194
let RIGHT_SCREEN_END_X = 384

let PLATFORM_COLUMN_COUNT = 5
let PLATFORM_COLUMN_X = 38

let platformWidth = 24
let platformHeight = 8

// don't forget to create a second rray for right platform
const entity_array = []

def createPlatformRow(fullRow):
   set_random_seed(local_time().millisecond)

   // generate random number array for left platform creation
   let leftScreenColumnnPos = []
   for columnIndex < PLATFORM_COLUMN_COUNT - 2:
      push(leftScreenColumnnPos, random_integer(0, 1))

   // create at least 1 platform
   push(leftScreenColumnnPos, 1)
   push(leftScreenColumnnPos, 0)
   shuffle(leftScreenColumnnPos)

   // create left platform row
   for platformPosIndex < PLATFORM_COLUMN_COUNT:
      if leftScreenColumnnPos[platformPosIndex] == 1 or fullRow:
         push(entity_array, make_entity
         ({
            pos: xy(LEFT_SCREEN_START_X + (platformPosIndex * PLATFORM_COLUMN_X) + platformWidth/2 + 7, 0),
            shape: "rect",
            size: xy(platformWidth, platformHeight),
            sprite: platform_sprite,
            pivot: xy(0, 0),
            vel: xy(0, 1),
            hasBeenToutch: false,
            isFalling: false,
            timer: 0,
         }))

   set_random_seed(local_time().millisecond)

   // generate random number array for right platform creation
   let rightScreenColumnnPos = []
   for columnIndex < PLATFORM_COLUMN_COUNT - 2:
      push(rightScreenColumnnPos, random_integer(0, 1))

   // create at least 1 platform
   push(rightScreenColumnnPos, 1)
   push(rightScreenColumnnPos, 0)
   shuffle(rightScreenColumnnPos)

   // create right platform row
   for platformPosIndex < PLATFORM_COLUMN_COUNT:
      if rightScreenColumnnPos[platformPosIndex] == 1 or fullRow:
         push(entity_array, make_entity
            ({
               pos: xy(RIGHT_SCREEN_START_X + (platformPosIndex * PLATFORM_COLUMN_X) + platformWidth/2 + 7, 0),
               shape: "rect",
               size: xy(platformWidth, platformHeight),
               sprite: platform_sprite,
               pivot: xy(0, 0),
               vel: xy(0, 1),
               hasBeenToutch: false,
               isFalling: false,
               timer: 0,
            }))

def collidePlayer(platform, players):
   for player in players:
      if overlaps(platform, player):
         return true
   return false

def platformUpdate(players, dt):
   //move platform and check for out of bound
   for platform in clone(entity_array):
      if platform.pos.y â‰¥ SCREEN_SIZE.y:
         remove_values(entity_array, platform)
         continue

      entity_move(platform, platform.pos + platform.vel)

      // check for collision and for switch between main and falling physics
      if platform.hasBeenToutch:
         platform.timer += dt
         if platform.timer > 1:
            if not platform.isFalling:
               platform.vel *= 1.05
      else if collidePlayer(platform, players):
         platform.hasBeenToutch = true
         platform.timer += dt

def platformDraw():
   for platform in entity_array:
      draw_entity(platform)